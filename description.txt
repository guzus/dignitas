Short description:
Decentralized reputation system for AI agents using trust graphs and PageRank

Description:
Dignitas is a decentralized reputation protocol that enables AI agents to discover and transact with trustworthy peers. At its core, it uses a modified PageRank algorithm where edges in the trust graph are weighted by real economic signals — x402 micropayments count 2x, positive feedback 1.2x, and negative feedback applies a -1.0x penalty, all with a 30-day time decay half-life. On top of this, Dignitas layers LLM-powered semantic search (via Gemini) so agents can find relevant peers using natural language queries, with final rankings blending PageRank scores (40%) and LLM relevancy (60%). The system is built on the x402 payment protocol and ERC-8004 standard, meaning every API call — discovery, scoring, interaction recording — is gated by micropayments, creating a self-sustaining economy. The stack includes a Python/FastAPI graph engine, a Node.js/Express x402 API gateway, a Next.js dashboard with interactive trust graph visualization, and a TypeScript client SDK for agent integration.

How it's made:
The system is split into four independently deployable services that communicate over REST.

The Graph Engine is a Python FastAPI server that maintains a directed graph using NetworkX. Each edge represents an agent-to-agent interaction (x402 payment, positive feedback, or negative feedback), weighted differently — x402 payments get 2.0x weight since they represent real economic commitment, positive feedback gets 1.2x, and negative feedback drops to 0.01x. All weights decay over time using an exponential half-life of 30 days, so stale reputation fades naturally. We run NetworkX's built-in PageRank with a 0.85 damping factor on this weighted graph and normalize scores to 0-1. For smart discovery, we pipe agent specs into Gemini 2.5 Flash with a structured prompt that returns a JSON map of address-to-relevancy-score, then blend it with PageRank using configurable weights (default 40/60 PageRank/relevancy).

The API Gateway is a Node.js/Express server that sits in front of the Graph Engine and gates paid endpoints behind x402 middleware. It's designed to work with the x402 payment protocol on Base Sepolia — agents pay $0.001 in USDC per API call for discovery, scoring, and interaction recording. The TypeScript client SDK wraps this with viem for wallet management, so any agent with a private key can plug in and start querying.

The Frontend is a Next.js 16 app using React 19, Tailwind, and shadcn/ui. The trust graph visualization uses react-force-graph-2d with dynamically imported components (no SSR) — nodes are sized by PageRank score and color-coded by trust tier. It includes a live leaderboard, an interactive demo panel for simulating agent interactions, and supports a mock data mode for standalone deployment without backend services.

One notably hacky piece: since the x402 npm package isn't publicly available yet, we wrote a mock middleware that simulates the payment verification flow and attaches fake payment IDs — this lets the entire payment-gated architecture work end-to-end in demo mode while preserving the exact API contract that real x402 would use. The client SDK similarly mocks the x402 axios wrapper, injecting wallet address headers as a stand-in for actual payment signatures. When the x402 package ships publicly, swapping in real payments is a one-line change in each service.

---

PRIZE: Arc - $10,000

Please add a sentence or two on why you're applicable for this prize:
Dignitas uses USDC on Base Sepolia as the sole payment token for its x402-gated API. Every paid endpoint — agent discovery, score lookup, interaction recording, smart search — charges $0.001 in USDC per query, making USDC the economic backbone of the reputation protocol.

Link to the line of code where the tech is used:
- https://github.com/guzus/dignitas/blob/573ca8d/api/src/server.ts#L69 — acceptedTokens: ['USDC']
- https://github.com/guzus/dignitas/blob/573ca8d/api/src/server.ts#L60 — QUERY_PRICE = '0.001' (USDC)
- https://github.com/guzus/dignitas/blob/573ca8d/api/src/server.ts#L68 — network: 'base-sepolia'

How easy is it to use the API / Protocol: 8

Additional feedback:
Integrating USDC via x402 was straightforward — the payment config just needed a recipient address, network, and accepted token list. The main friction was that the x402 npm package isn't publicly available yet, so we wrote a mock middleware that preserves the exact contract for a seamless swap when it ships.

---

PRIZE: ENS - $5,000

Please add a sentence or two on why you're applicable for this prize:
Dignitas uses ENS names as human-readable identifiers for AI agents in the trust graph. Agents can register with their .eth name, and all API endpoints — score lookup, interaction recording, agent discovery, and spec retrieval — accept ENS names which are resolved to addresses via viem's ENS resolution against Ethereum mainnet. This makes the agent reputation layer more accessible by letting users query "codeguard.eth" instead of raw hex addresses.

Link to the line of code where the tech is used:
- https://github.com/guzus/dignitas/blob/573ca8d/api/src/server.ts#L30-L52 — ENS resolution functions using viem (resolveEnsName, reverseResolveEns)
- https://github.com/guzus/dignitas/blob/573ca8d/api/src/server.ts#L79 — /ens/resolve/:nameOrAddress endpoint
- https://github.com/guzus/dignitas/blob/573ca8d/client/dignitas-client.ts#L21-L24 — ENS public client setup
- https://github.com/guzus/dignitas/blob/573ca8d/client/dignitas-client.ts#L48-L66 — resolveEns, lookupEns, resolveNameOrAddress methods
- https://github.com/guzus/dignitas/blob/573ca8d/graph_engine/main.py#L752 — ens_name field in AgentSpecRequest model

How easy is it to use the API / Protocol: 9

Additional feedback:
viem's built-in ENS support made integration very smooth. We use getEnsAddress for forward resolution and getEnsName for reverse lookups against mainnet, while the actual payments happen on Base Sepolia. The two-chain approach (mainnet for identity, L2 for payments) works cleanly.